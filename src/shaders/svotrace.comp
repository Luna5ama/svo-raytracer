#version 430 core
layout(binding = 0, rgba8) uniform image2D framebufferImage;
layout(location = 0) uniform vec3 cam[5] = {
  vec3(0.0, 2.0, 40.0), // <- position
  vec3(-1.0, -1.0, -1.0), vec3(-1.0, 1.0, -1.0), // <- left corner directions
  vec3(1.0, -1.0, -1.0), vec3(1.0, 1.0, -1.0) // <- right corner directions
};
layout(location = 5) uniform int frameNumber;
uniform isamplerBuffer bufferTex;
layout(std430, binding = 7) buffer shaderStorage{
  uint[] octreeBuffer;
};
layout(location = 8) uniform vec3 camPos;
layout(location = 9) uniform int bufferEnd;
int endOffset = bufferEnd / 4 + 1;
struct box {
  vec3 min, max, color, emi;
  //float3 emi, color;
};
struct sphere{
    float radius;
    vec3 pos, color, emi;
};
float rand(vec2 co){
    return (fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453));
}
uint wang_hash(uint seed)
{
    seed = (seed ^ uint(61)) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
#define NUM_BOXES 7
#define EPSILON 3.552713678800501e-15f
#define PI 3.14159265359f
#define SAMPLES 1
#define NODE_SIZE 6
#define LEAF_SIZE 1
#define MAX_SCALE 23 //IDK WHY BUT THIS HAS TO BE 23 OR ELSE EVERYTHING BREAKS
#define INDEX_SIZE 4
#define MAX_RAYCAST_ITERATIONS 1000

struct hitinfo {
  float near;
  int i;
  vec3 normal;
  vec3 hitpos;
};
struct Ray {
    vec3 origin;
    vec3 dir;
};

const int levels = 8;

struct Material{
  vec3 color;
  vec3 emission;
  float roughness;
};

const Material materials[8] = {
  {{1.0f, 1.0f, 1.0f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{1.0f, 0.9f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{1.0f, 0.8f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{1.0f, 0.7f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{1.0f, 0.6f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{1.0f, 0.5f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{1.0f, 0.4f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{1.0f, 0.3f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f}
};

vec3 debugColor = vec3(1, 1, 1);
bool debugFlag = false;

int getByte(uint bytePointer){
  uint r = bytePointer % 4;
  uint i = bytePointer / 4;
  return int((octreeBuffer[i] & (0x000000ff << (r*8u))) >> (r*8u));
}

struct Node{
    int value;
    int cp;
    int leafMask;     
};

Node extractNode(uint nodePointer){
  //if(nodePointer >= 467 && nodePointer <= 473) debugFlag = true;
  if(nodePointer == 12) debugFlag = true;
  Node ret = {
    getByte(nodePointer++),
    (getByte(nodePointer++) << 24) + (getByte(nodePointer++) << 16) + (getByte(nodePointer++) << 8) + getByte(nodePointer++),
    getByte(nodePointer++)
  };
  //if(ret.leafMask != 0) debugFlag = true;
  //if(ret.cp < 0) debugFlag = true;
  return ret;
}

Node extractLeaf(uint nodePointer){
  Node ret = {getByte(nodePointer), 0, 0};
  return ret;
}

Node extractChild(uint childPointer, uint child, int leafMask){
  int i = 0;
  uint pointer = childPointer;
  //if(leafMask == 0xff) debugFlag = true;
  while(i < child){
    if((leafMask & (0x00000001 << i)) == (0x00000001 << i)){ 
      //debugFlag = true;
      pointer += LEAF_SIZE;
    }else{
      pointer += NODE_SIZE;
    }
    i++;
  }
  if((leafMask & (0x00000001 << child)) == (0x00000001 << child)){
    //debugFlag = true;
    return extractLeaf(pointer);
  }else{
    return extractNode(pointer);
  }
}

//int testPointer = 0;
//Node rootTest = extractNode(testPointer);

void createCamRay(Ray ray, int x_coord, int y_coord, int width, int height){
    float fx = float(x_coord) / float(width);
    float fy = float(y_coord) / float(height);
    
    float aspect_ratio = float(width) / float(height);
    float fx2 = (fx - 0.5f) * aspect_ratio;
    float fy2 = fy - 0.5f;
    
    vec3 pixel_pos = vec3(fx2, -fy2, 0.0f);
    //Ray ray;
    ray.origin = vec3(0.0, 2.0, 5.0);
    ray.dir = normalize(pixel_pos - ray.origin);
    //camray = ray;
}

struct retInfo{
  vec2 hit;
  vec3 normal;
};

retInfo intersectBox(vec3 origin, vec3 invdir, box b) {
  vec3 tMin = (b.min - origin) * invdir;
  vec3 tMax = (b.max - origin) * invdir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  vec3 hitpoint = origin + (1.0f / invdir) * tNear;
  //vec3 p = (b.min - b.max) / 2.0f;
  vec3 c = (b.min + b.max) * 0.5f;
  vec3 p = (hitpoint - c);
  vec3 d = vec3(abs(b.min.x - b.max.x), abs(b.min.y - b.max.y), abs(b.min.z - b.max.z)) / 2.0f;
  float bias = 1.00001;
  
  vec3 normal = vec3(int(p.x / abs(d.x) * bias), 
                      int(p.y / abs(d.y) * bias), 
                      int(p.z / abs(d.z) * bias));
      
  return retInfo(vec2(tNear, tFar), normal);
}
  /*
  NODE STRUCTURE
  branch
  0 :: value - 1 byte
  1 :: child pointer - 4 bytes
  2 ::
  3 ::
  4 ::
  5 :: leaf mask

  leaf
  0 :: value - 1 byte
  */
  
struct castResult {
  Node node;
  float t;
  bool hit;
  uint scale;
  vec3 debugColor;
  vec3 normal;
};

struct stackEntry {
    Node node;
    float tmax;
} octstack[MAX_SCALE + 1];

int stack_ptr = 0;
void stack_reset() {stack_ptr = 0;}
void stack_push(in stackEntry s) {octstack[stack_ptr++] = s;}
stackEntry stack_pop() {return octstack[--stack_ptr];}
bool stack_empty() {return stack_ptr == 0;}


bool intersectOctree(vec3 origin, vec3 dir, vec3 invdir, out castResult res){

  res.debugColor = vec3(0.3, 0.3, 0.6);
  //set origin to nearest intersection with octree
  float eps = pow(2, -MAX_SCALE);
  box bbox = {vec3(1.0f), vec3(2.0f), vec3(0.0f), vec3(0.0f)};
  retInfo lambda = intersectBox(origin, invdir, bbox);
  if(lambda.hit.y >= 0 && lambda.hit.x < lambda.hit.y && lambda.hit.x > 0){
    origin += lambda.hit.x * dir;
  }
  stack_reset();
  Node parent = extractNode(0);

  int iter = 0;

  if(abs(dir.x) < eps) dir.x = eps * sign(dir.x);
  if(abs(dir.y) < eps) dir.y = eps * sign(dir.y);
  if(abs(dir.z) < eps) dir.z = eps * sign(dir.z);
  
  float tx_coef = 1.0f / -abs(dir.x);
  float ty_coef = 1.0f / -abs(dir.y);
  float tz_coef = 1.0f / -abs(dir.z);

  float tx_bias = tx_coef * origin.x;
  float ty_bias = ty_coef * origin.y;
  float tz_bias = tz_coef * origin.z;

  uint octant_mask = 7; 
  if(dir.x > 0.0f) octant_mask ^= 1u, tx_bias = 3.0f * tx_coef - tx_bias;
  if(dir.y > 0.0f) octant_mask ^= 2u, ty_bias = 3.0f * ty_coef - ty_bias;
  if(dir.z > 0.0f) octant_mask ^= 4u, tz_bias = 3.0f * tz_coef - tz_bias;

  float t_min = max(max(2.0f * tx_coef - tx_bias, 2.0f * ty_coef - ty_bias), 2.0f * tz_coef - tz_bias);
  float t_max = min(min(tx_coef - tx_bias, ty_coef - ty_bias), tz_coef - tz_bias);
  t_min = max(t_min, 0.0f);
  t_max = min(t_max, 1.0f);
  float h = t_max;

  uint idx = 0;
  vec3 pos = vec3(1.0f, 1.0f, 1.0f);
  int scale = MAX_SCALE - 1;
  float scale_exp2 = 0.5f;
  int child_descriptor = 0;

  if(1.5f * tx_coef - tx_bias > t_min) idx ^= 1u, pos.x = 1.5f;
  if(1.5f * ty_coef - ty_bias > t_min) idx ^= 2u, pos.y = 1.5f;
  if(1.5f * tz_coef - tz_bias > t_min) idx ^= 4u, pos.z = 1.5f;
  res.hit = true;
  int val = 0;

  while(scale < MAX_SCALE){
    iter++;
    if(iter > MAX_RAYCAST_ITERATIONS){
      return false;
    }
    if(child_descriptor == 0){
      child_descriptor = parent.cp;
    }
    float tx_corner = pos.x * tx_coef - tx_bias;
    float ty_corner = pos.y * ty_coef - ty_bias;
    float tz_corner = pos.z * tz_coef - tz_bias;
    float tc_max = min(min(tx_corner, ty_corner), tz_corner);

    uint child_shift = idx ^ octant_mask;

    // if(endOffset < (bufferEnd/4) + 250){
    //   octreeBuffer[endOffset++] = child_descriptor;
    // }

    // if(child_descriptor < 0) debugFlag = true;

    Node child = extractChild(child_descriptor, child_shift, parent.leafMask);
    if(child.value != 0 && t_min <= t_max){ //check if voxel exists
      // if(child.cp == 0 && child.value != 0){
      //   res.hit = true;
      //   break;
      // }

      float tv_max = min(t_max, tc_max);
      float one_half = scale_exp2 * 0.5f;
      float tx_center = one_half * tx_coef + tx_corner;
      float ty_center = one_half * ty_coef + ty_corner;
      float tz_center = one_half * tz_coef + tz_corner;

      if(t_min <= tv_max){
        if(child.cp == 0){ //if voxel is a leaf
          break;
        }

        //PUSH
        if(tc_max < h){
          stackEntry se = {parent, t_max}; 
          octstack[scale] = se;
        }
        h = tc_max;

        parent = child; //??????????

        idx = 0;
        scale--;
        scale_exp2 = one_half;

        if(tx_center > t_min) idx ^= 1u, pos.x += scale_exp2;
        if(ty_center > t_min) idx ^= 2u, pos.y += scale_exp2;
        if(tz_center > t_min) idx ^= 4u, pos.z += scale_exp2;

        t_max = tv_max;
        child_descriptor = 0;
        continue;
      }
    }
    //ADVANCE
    uint step_mask = 0;
    if(tx_corner <= tc_max) step_mask ^= 1u, pos.x -= scale_exp2;
    if(ty_corner <= tc_max) step_mask ^= 2u, pos.y -= scale_exp2;
    if(tz_corner <= tc_max) step_mask ^= 4u, pos.z -= scale_exp2;

    t_min = tc_max;
    idx ^= step_mask;

    //POP
    if((idx & step_mask) != 0){
      uint differing_bits = 0;
      if((step_mask & 1u) != 0) differing_bits |= floatBitsToUint(pos.x) ^ floatBitsToUint(pos.x + scale_exp2);
      if((step_mask & 2u) != 0) differing_bits |= floatBitsToUint(pos.y) ^ floatBitsToUint(pos.y + scale_exp2);
      if((step_mask & 4u) != 0) differing_bits |= floatBitsToUint(pos.z) ^ floatBitsToUint(pos.z + scale_exp2);
      scale = findMSB(differing_bits);
      scale_exp2 = uintBitsToFloat((scale - MAX_SCALE + 127u) << 23u);

      stackEntry se = octstack[scale];
      parent = se.node;
      t_max = se.tmax;

      uint shx = floatBitsToUint(pos.x) >> scale;
      uint shy = floatBitsToUint(pos.y) >> scale;
      uint shz = floatBitsToUint(pos.z) >> scale;
      pos.x = uintBitsToFloat(shx << scale);
      pos.y = uintBitsToFloat(shy << scale);
      pos.z = uintBitsToFloat(shz << scale);
      idx = (shx & 1u) | ((shy & 1u) << 1u) | ((shz & 1u) << 2u);
      h = 0.0f;
      child_descriptor = 0;
    }
  }

  if(scale >= MAX_SCALE){
    t_min = 2.0f;
    res.hit = false;
    //res.debugColor = vec3(0, 0, 0);
    res.debugColor = vec3(0.02) * iter;
    return false;
  }
  
  if((octant_mask & 1u) == 0u) pos.x = 3.0f - scale_exp2 - pos.x;
  if((octant_mask & 2u) == 0u) pos.y = 3.0f - scale_exp2 - pos.y;
  if((octant_mask & 4u) == 0u) pos.z = 3.0f - scale_exp2 - pos.z;
  vec3 hitpos;
  hitpos.x = min(max(origin.x + t_min * dir.x, pos.x + eps), pos.x + scale_exp2 - eps);
  hitpos.y = min(max(origin.y + t_min * dir.y, pos.y + eps), pos.y + scale_exp2 - eps);
  hitpos.z = min(max(origin.z + t_min * dir.z, pos.z + eps), pos.z + scale_exp2 - eps);

  float tx_corner = tx_coef * (pos.x + scale_exp2) - tx_bias;
  float ty_corner = ty_coef * (pos.y + scale_exp2) - ty_bias;
  float tz_corner = tz_coef * (pos.z + scale_exp2) - tz_bias;
  vec3 norm = (tx_corner > ty_corner && tx_corner > tz_corner)
    ? vec3(-1, 0, 0)
    : (ty_corner > tz_corner ? vec3(0, -1, 0) : vec3(0, 0, -1));

  res.t = t_min;
  //res.node = extractNode(child_descriptor);
  res.normal = norm;
  res.scale = scale;
  res.hit = true;
  res.debugColor = vec3(0.02) * iter;

  return scale < MAX_SCALE && t_min <= t_max;
}


vec3 trace(vec3 origin, vec3 dir, float seed0, float seed1){
  castResult res;
  res.t = 2.0f;
  Node outnode;
  vec3 accum_color = vec3(0.0f, 0.0f, 0.0f);
  vec3 mask = vec3(1.0f, 1.0f, 1.0f);
  if(intersectOctree(origin, dir, 1.0/dir, res)){
    return res.debugColor;
    //return materials[res.node.value].color;
  }else{
    return res.debugColor;
    //return vec3(0);
  }
}

layout(local_size_x = 8, local_size_y = 8) in;
void main(void) {
  ivec2 px = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebufferImage);
  if (any(greaterThanEqual(px, size)))
    return;
  vec2 p = (vec2(px) + vec2(0.5)) / vec2(size);
  //vec2 p = (vec2(px) / vec2(size));
  vec3 dir = mix(mix(cam[1], cam[2], p.y), mix(cam[3], cam[4], p.y), p.x);
  
  
  vec3 finalcolor = vec3(0.0f, 0.0f, 0.0f);
  int samples = SAMPLES;
  float invsamples = 1.0f / SAMPLES;
  
  for(int i = 0; i < samples; i++){
    finalcolor += trace(camPos, normalize(dir), 
        px.x + rand(vec2(i, i)) + rand(vec2(i+1, i+1)), 
        px.y + rand(vec2(i, i)) + rand(vec2(i+1, i+1))) * invsamples;
  }
  vec3 tempColor = finalcolor;

  //Node debugNode = extractNode(407);
  if(debugFlag) debugColor = vec3(0, 1, 0);
  if(px.x < 10 && px.y < 10) finalcolor = debugColor;
  
  imageStore(framebufferImage, px, (vec4(finalcolor, 1.0)));
}