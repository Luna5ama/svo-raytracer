#version 430 core
layout(binding = 0, rgba8) uniform image2D framebufferImage;
layout(location = 0) uniform vec3 cam[5] = {
  vec3(0.0, 2.0, 40.0), // <- position
  vec3(-1.0, -1.0, -1.0), vec3(-1.0, 1.0, -1.0), // <- left corner directions
  vec3(1.0, -1.0, -1.0), vec3(1.0, 1.0, -1.0) // <- right corner directions
};
layout(location = 5) uniform int frameNumber;
layout(location = 6) uniform int bufferEnd;
uniform isamplerBuffer bufferTex;
layout(std430, binding = 7) buffer shaderStorage{
  int[] octreeBuffer;
};
layout(location = 8) uniform vec3 camPos;
//uniform int newBuffer = 0;
struct box {
  vec3 min, max, color, emi;
  //float3 emi, color;
};
struct sphere{
    float radius;
    vec3 pos, color, emi;
};
float rand(vec2 co){
    return (fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453));
}
uint wang_hash(uint seed)
{
    seed = (seed ^ uint(61)) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
#define NUM_BOXES 7
#define EPSILON 0.00003f
#define PI 3.14159265359f
#define SAMPLES 16
#define NODE_SIZE 8
#define MAX_SCALE 4
#define INDEX_SIZE 4

struct hitinfo {
  float near;
  int i;
  vec3 normal;
  vec3 hitpos;
};
struct Ray {
    vec3 origin;
    vec3 dir;
};

const int levels = 8;

struct Material{
  vec3 color;
  vec3 emission;
  float roughness;
};

const Material materials[3] = {
  {{1.0f, 0.2f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{0.2f, 1.0f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f},
  {{1.0f, 0.0f, 0.2f}, {0.2f, 0.2f, 0.2f}, 0.3f}
};

vec3 debugColor = vec3(1, 1, 1);

struct Node{
    int size;
    int value;
    vec3 pos;
    int cp;
    int isLeaf;     
};

Node extractNode(int nodePointer){
  Node ret = {
    octreeBuffer[nodePointer++],
    octreeBuffer[nodePointer++],
    vec3(
      octreeBuffer[nodePointer++],
      octreeBuffer[nodePointer++],
      octreeBuffer[nodePointer++]
    ),
    octreeBuffer[nodePointer++] | (octreeBuffer[nodePointer++]),
    octreeBuffer[nodePointer++]
  };
  return ret;
}
int testPointer = 0;
Node rootTest = extractNode(testPointer);

box boxes[NUM_BOXES] = {
  {vec3(-5.0, -0.1, -5.0), vec3(5.0, 0.0, 5.0), vec3(0.9f, 0.5f, 0.5f), vec3(0.0f, 0.0f, 0.0f)},  // <- bottom
  {vec3(-5.1, 0.0, -5.0), vec3(-5.0, 5.0, 5.0), vec3(0.5f, 0.9f, 0.5f), vec3(0.0f, 0.0f, 0.0f)},  // <- left
  {vec3(5.0, 0.0, -5.0), vec3(5.1, 5.0, 5.0), vec3(0.5f, 0.5f, 0.9f), vec3(0.0f, 0.0f, 0.0f)},    // <- right
  {vec3(-5.0, 0.0, -5.1), vec3(5.0, 5.0, -5.0), vec3(0.5f, 0.5f, 0.5f), vec3(0.0f, 0.0f, 0.0f)},  // <- back
  {vec3(0.0, 1.0, 0.0), vec3(1.0, 2.0, 1.0), vec3(1.0f, 1.0f, 1.0f), vec3(9.0f, 8.0f, 6.0f)},   // <- table top
  //{vec3(-1.0, 3.0, -1.0), vec3(0.0, 5.0, 0.0), vec3(2.0f, 4.4f, 1.5f), vec3(8.0f, 4.4f, 1.5f)}, // <- table foot
  {vec3(-2.0, 2.0, -2.0), vec3(-1.0, 3.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.0f, 0.0f, 0.0f)},  // <- table foot
  {vec3(2.0, 2.0, -2.0), vec3(3.0, 3.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.0f, 0.0f, 0.0f)},   // <- table foot
  //{rootTest.pos, rootTest.pos + rootTest.size, vec3(0.5f, 0.5f, 0.5f), vec3(0.0f, 0.0f, 0.0f)}
  //{vec3(0.8, 0.0,  0.8), vec3(1.0, 1.0, 1.0), vec3(0.3f, 0.4f, 0.5f), vec3(0.3f, 0.4f, 0.5f)}     // <- table foot
};

/*bool intersectSphere(vec3 origin, vec3 invdir, sphere s){
    vec3 rayToCenter = s.pos - origin;
    
    float b = dot(rayToCenter, dir);
    float c = dot(rayToCenter, rayToCenter) - s.radius * s.radius;
    float disc = b * b - c;
    float t = b - sqrt(disc);
    
    if(disc < 0.0f) return false;
    else t = b - sqrt(disc);
    
    if(t < 0.0f){
        t = b + sqrt(disc);
    }
}*/

void createCamRay(Ray ray, int x_coord, int y_coord, int width, int height){
    float fx = float(x_coord) / float(width);
    float fy = float(y_coord) / float(height);
    
    float aspect_ratio = float(width) / float(height);
    float fx2 = (fx - 0.5f) * aspect_ratio;
    float fy2 = fy - 0.5f;
    
    vec3 pixel_pos = vec3(fx2, -fy2, 0.0f);
    //Ray ray;
    ray.origin = vec3(0.0, 2.0, 5.0);
    ray.dir = normalize(pixel_pos - ray.origin);
    //camray = ray;
}

struct retInfo{
  vec2 hit;
  vec3 normal;
};

retInfo intersectBox(vec3 origin, vec3 invdir, box b) {
  vec3 tMin = (b.min - origin) * invdir;
  vec3 tMax = (b.max - origin) * invdir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  vec3 hitpoint = origin + (1.0f / invdir) * tNear;
  //vec3 p = (b.min - b.max) / 2.0f;
  vec3 c = (b.min + b.max) * 0.5f;
  vec3 p = (hitpoint - c);
  vec3 d = vec3(abs(b.min.x - b.max.x), abs(b.min.y - b.max.y), abs(b.min.z - b.max.z)) / 2.0f;
  float bias = 1.00001;
  
  vec3 normal = vec3(int(p.x / abs(d.x) * bias), 
                      int(p.y / abs(d.y) * bias), 
                      int(p.z / abs(d.z) * bias));
      
  return retInfo(vec2(tNear, tFar), normal);
}
// bool intersectBoxes(vec3 origin, vec3 invdir, out hitinfo info) {
//   float smallest = 1.0/0.0;
//   bool found = false;
//   for (int i = 0; i < NUM_BOXES; i++) {
//     box b = boxes[i];
//     retInfo lambda = intersectBox(origin, invdir, b);
//     if (lambda.hit.y >= 0.0 && lambda.x < lambda.y && lambda.x < smallest) {
//       info.near = lambda.x;
//       info.i = i;
//       vec3 hitpoint = origin + (1.0f / invdir) * info.near;
//       //vec3 p = (b.min - b.max) / 2.0f;
//       vec3 c = (b.min + b.max) * 0.5f;
//       vec3 p = (hitpoint - c);
//       vec3 d = vec3(abs(b.min.x - b.max.x), abs(b.min.y - b.max.y), abs(b.min.z - b.max.z)) / 2.0f;
//       float bias = 1.00001;
      
//       vec3 normal = vec3(int(p.x / abs(d.x) * bias), 
//                          int(p.y / abs(d.y) * bias), 
//                          int(p.z / abs(d.z) * bias));
      
//       info.normal = normal;
      
//       smallest = lambda.x;
//       found = true;
//     }
//   }
//   return found;
// }
    /*
    NODE STRUCTURE---all integers
    0 :: size
    1 :: value 
    2 :: x - position
    3 :: y
    4 :: z
    5 :: child pointer
    6 ::
    7 :: is leaf boolean
     */
     

struct stackEntry {
    Node node;
    float tmax;
} octstack[MAX_SCALE];

int stack_ptr = 0;
void stack_reset() {stack_ptr = 0;}
void stack_push(in stackEntry s) {octstack[stack_ptr++] = s;}
stackEntry stack_pop() {return octstack[--stack_ptr];}
bool stack_empty() {return stack_ptr == 0;}

void intersectOctree(vec3 origin, vec3 dir, vec3 invdir, out hitinfo info){
  stack_reset();
  Node parent = extractNode(0);
  float max_size = parent.size;
  int iter = 0;

  if(abs(dir.x) < EPSILON) dir.x = EPSILON * sign(dir.x);
  if(abs(dir.y) < EPSILON) dir.y = EPSILON * sign(dir.y);
  if(abs(dir.z) < EPSILON) dir.z = EPSILON * sign(dir.z);
  
  float tx_coef = 1.0f / -abs(dir.x);
  float ty_coef = 1.0f / -abs(dir.y);
  float tz_coef = 1.0f / -abs(dir.z);

  float tx_bias = tx_coef * origin.x;
  float ty_bias = ty_coef * origin.y;
  float tz_bias = tz_coef * origin.z;

  int octant_mask = 7;
  if(dir.x > 0.0f) octant_mask ^= 1, tx_bias = 3.0f * tx_coef - tx_bias;
  if(dir.y > 0.0f) octant_mask ^= 2, ty_bias = 3.0f * ty_coef - ty_bias;
  if(dir.z > 0.0f) octant_mask ^= 4, tz_bias = 3.0f * tz_coef - tz_bias;

  float t_min = max(max(2.0f * tx_coef - tx_bias, 2.0f * ty_coef - ty_bias), 2.0f * tz_coef - tz_bias);
  float t_max = min(min(tx_coef - tx_bias, ty_coef - ty_bias), tz_coef - tz_bias);
  float h = t_max;
  t_min = max(t_min, 0.0f);
  t_max = min(t_max, 1.0f);

  int idx = 0;
  vec3 pos = vec3(1.0f);
  int scale = MAX_SCALE - 1;
  float scale_exp2 = 0.5f;
  int child_descriptor = 0;

  if(1.5f * tx_coef - tx_bias > t_min) idx ^= 1, pos.x = 1.5f;
  if(1.5f * ty_coef - ty_bias > t_min) idx ^= 2, pos.y = 1.5f;
  if(1.5f * tz_coef - tz_bias > t_min) idx ^= 4, pos.z = 1.5f;
  bool hit = false;
  int val = 0;

  while(scale < MAX_SCALE){
    iter++;
    if(child_descriptor == 0){
      child_descriptor = parent.cp;
    }
    float tx_corner = pos.x * tx_coef - tx_bias;
    float ty_corner = pos.y * ty_coef - ty_bias;
    float tz_corner = pos.z * tz_coef - tz_bias;
    float tc_max = min(min(tx_corner, ty_corner), tz_corner);

    int child_shift = idx ^ octant_mask;
    Node child = extractNode(child_descriptor + child_shift * NODE_SIZE);
    if(child.value != 0 && t_min <= t_max){
      // if(child.size <= max_size / (2 * iter)){
      //   break;
      // }

      float tv_max = min(t_max, tc_max);
      float one_half = scale_exp2 * 0.5f;
      float tx_center = one_half * tx_coef + tx_corner;
      float ty_center = one_half * ty_coef + ty_corner;
      float tz_center = one_half * tz_coef + tz_corner;

      if(t_min <= tv_max){
        if(child.cp == 0){
          val = child.value;
          break;
        }

        if(tc_max < h){
          stackEntry se = {parent, t_max};
          octstack[scale] = se;
        }
        h = tc_max;

        parent = child; //??????????

        idx = 0;
        scale--;
        scale_exp2 = one_half;

        if(tx_center > t_min) idx ^= 1, pos.x += scale_exp2;
        if(ty_center > t_min) idx ^= 2, pos.y += scale_exp2;
        if(tz_center > t_min) idx ^= 4, pos.z += scale_exp2;

        t_max = tv_max;
        child_descriptor = 0;
        continue;
      }
    }

    int step_mask = 0;
    if(tx_corner <= tc_max) step_mask ^= 1, pos.x -= scale_exp2;
    if(ty_corner <= tc_max) step_mask ^= 2, pos.y -= scale_exp2;
    if(tz_corner <= tc_max) step_mask ^= 4, pos.z -= scale_exp2;

    t_min = t_max;
    idx ^= step_mask;

    if((idx & step_mask) != 0){
      uint differing_bits = 0;
      if((step_mask & 1) != 0) differing_bits |= floatBitsToInt(pos.x) ^ floatBitsToInt(pos.x + scale_exp2);
      if((step_mask & 2) != 0) differing_bits |= floatBitsToInt(pos.y) ^ floatBitsToInt(pos.y + scale_exp2);
      if((step_mask & 4) != 0) differing_bits |= floatBitsToInt(pos.z) ^ floatBitsToInt(pos.z + scale_exp2);
      scale = (floatBitsToInt(float(differing_bits)) >> 23) - 127;
      scale_exp2 = intBitsToFloat((scale - MAX_SCALE + 127) << 23);

      stackEntry se = octstack[scale];
      parent = se.node;
      t_max = se.tmax;

      int shx = floatBitsToInt(pos.x) >> scale;
      int shy = floatBitsToInt(pos.y) >> scale;
      int shz = floatBitsToInt(pos.z) >> scale;
      pos.x = intBitsToFloat(shx << scale);
      pos.y = intBitsToFloat(shy << scale);
      pos.z = intBitsToFloat(shz << scale);
      idx = (shx & 1) | ((shy & 1) << 1) | ((shz & 1) << 2);
      h = 0.0f;
      child_descriptor = 0;
    }
  }
  
  if((octant_mask & 1) == 0) pos.x = 3.0f - scale_exp2 - pos.x;
  if((octant_mask & 2) == 0) pos.y = 3.0f - scale_exp2 - pos.y;
  if((octant_mask & 4) == 0) pos.z = 3.0f - scale_exp2 - pos.z;
  vec3 hitpos;
  hitpos.x = min(max(origin.x + t_min * dir.x, pos.x + EPSILON), pos.x + scale_exp2 - EPSILON);
  hitpos.y = min(max(origin.y + t_min * dir.y, pos.y + EPSILON), pos.y + scale_exp2 - EPSILON);
  hitpos.z = min(max(origin.z + t_min * dir.z, pos.z + EPSILON), pos.z + scale_exp2 - EPSILON);
  info.i = val;
  info.hitpos = hitpos;
}

bool intersectOctreeNew(vec3 origin, vec3 dir, vec3 invdir, out hitinfo info){

  /*
    CONSIDERATIONS:
    1. keep track of position normalized to (0, 1), multiply by root scale when computing intersections
    2. normalize ray directions so that we are moving in the + direction for every axis, store in octant mask
    3. 
  */

  stack_reset();
  
  float tmin = 0;
  float tmax = 1;
  Node parent = extractNode(0);
  box boundingBox = {parent.pos - parent.size * 0.5, parent.pos + parent.size * 0.5, vec3(0), vec3(0)};
  retInfo rootLambda = intersectBox(origin, invdir, boundingBox);
  tmin = rootLambda.hit.x;
  tmax = rootLambda.hit.y;
  float h = tmax;
  float rootSize = parent.size;
  vec3 pos = parent.pos / rootSize;
  
  float dx = invdir.x;
  float dy = invdir.y;
  float dz = invdir.z;
  float px = -origin.x*dx;
  float py = -origin.y*dy;
  float pz = -origin.z*dz;

  vec3 octantmask = vec3(sign(dir));
  vec3 mask = vec3(sign(origin.x - parent.pos.x), sign(origin.y - parent.pos.y), sign(origin.z - parent.pos.z));

  vec3 smcorner = pos - parent.size * octantmask * 0.5 / rootSize;
  vec3 bgcorner = pos + parent.size * octantmask * 0.5 / rootSize;
  float tcmin = max(dx*smcorner.x + px, max(dy*smcorner.y + py, dz*smcorner.z + pz));
  float tcmax = min(dx*bgcorner.x + px, max(dy*bgcorner.y + py, dz*bgcorner.z + pz));
  int idx = 0;
  if(dx*parent.pos.x + px <= tcmin) idx ^= 1;
  if(dy*parent.pos.y + py <= tcmin) idx ^= 2;
  if(dz*parent.pos.z + pz <= tcmin) idx ^= 4;
  Node current = extractNode(parent.cp + idx * NODE_SIZE);
  uint curLOD = 0;
  int maxLOD = MAX_SCALE;

  while(curLOD < maxLOD){
    if(current.value != 0 && tmin <= tmax){
      box bb = {current.pos-current.size*0.5, current.pos+current.size*0.5, vec3(0), vec3(0)};
      retInfo lambda = intersectBox(origin + tmin, invdir, bb);
      float tvmin = lambda.hit.x;
      float tvmax = lambda.hit.y;
      
      if(tvmin <= tvmax){
        if(current.cp == 0){
          info.near = tvmin;
          info.i = current.value;
          info.normal = lambda.normal;
          return true;
        }
        if(tcmax < h){
          stackEntry se = {parent, tmax};
          //stack_push(se);
          octstack[curLOD] = se;
        }
        h = tcmax;
        curLOD++;
        idx = 0;
        if(dx*current.pos.x + px <= tcmin) idx ^= 1;
        if(dy*current.pos.y + py <= tcmin) idx ^= 2;
        if(dz*current.pos.z + pz <= tcmin) idx ^= 4;
        tmin = tvmin;
        tmax = tvmax;
        parent = current;
        current = extractNode(current.cp + idx * NODE_SIZE);
        continue;
      }
    }
    
    int stepMask = 0;
    mask = vec3(sign(origin.x - current.pos.x), sign(origin.y - current.pos.y), sign(origin.z - current.pos.z));
    bgcorner = current.pos + current.size * mask * 0.5;
    if(dx*bgcorner.x + px >= tcmax) stepMask ^= 1;
    if(dy*bgcorner.y + py >= tcmax) stepMask ^= 2;
    if(dz*bgcorner.z + pz >= tcmax) stepMask ^= 4;
    idx ^= stepMask;
    tmin = tcmax;
    vec3 newpos = current.pos + current.size * 0.5 * mask;

    if((idx & stepMask) != 0){
      uint differingBits = 0;
      if(bool(stepMask & 1)) differingBits |= floatBitsToUint(current.pos.x) ^ floatBitsToUint(newpos.x);
      if(bool(stepMask & 2)) differingBits |= floatBitsToUint(current.pos.y) ^ floatBitsToUint(newpos.y);
      if(bool(stepMask & 4)) differingBits |= floatBitsToUint(current.pos.z) ^ floatBitsToUint(newpos.z);
      curLOD = (floatBitsToUint(float(differingBits)) >> 23) - 127;
      if(curLOD > maxLOD) return false;
      parent = octstack[curLOD].node;
      tmax = octstack[curLOD].tmax;

      int shX = int(floatBitsToUint(newpos.x) >> curLOD);
      int shY = int(floatBitsToUint(newpos.y) >> curLOD);
      int shZ = int(floatBitsToUint(newpos.z) >> curLOD);
      newpos.x = uintBitsToFloat(shX << curLOD);
      newpos.y = uintBitsToFloat(shY << curLOD);
      newpos.z = uintBitsToFloat(shZ << curLOD);
      idx = (shX & 1) | ((shY & 1) << 1) | ((shZ & 1) << 2);
      h = 0;
    }
    current = extractNode(parent.cp + idx * NODE_SIZE);
  }
  return false;
}

vec3 trace(vec3 origin, vec3 dir, float seed0, float seed1){
  hitinfo info;
  vec3 accum_color = vec3(0.0f, 0.0f, 0.0f);
  vec3 mask = vec3(1.0f, 1.0f, 1.0f);
  for(int bounces = 0; bounces < 1; bounces++){

    // if(!intersectOctree(origin, dir, 1.0/dir, info)){
    //   return accum_color += mask * vec3(0.15f, 0.15f, 0.15f);
    // }
    // else{
    //   return materials[info.i].color;
    // }

    intersectOctree(origin, dir, 1.0/dir, info);
    if(info.i != 0) return materials[info.i].color;

    // if(!intersectBoxes(origin, 1.0/dir, info)){
    //     return accum_color += mask * vec3(0.15f, 0.15f, 0.25f);
    // }
    box hitbox = boxes[info.i];
    vec3 hitpoint = info.hitpos;
    
    //vec3 normal = normalize(hitpoint - ((hitbox.min + hitbox.max) / 2.0f)); //calculating normal for SPHERE, not RECTANGULAR PRISM
    vec3 normal = info.normal;
    if(dot(normal, dir) > 0){
        normal = -normal;
    }
    
    vec3 normal_facing = dot(normal, dir) < 0.0f ? normal : normal * (-1.0f);
    
    float rand1 = 2.0f * PI * rand(vec2(seed0, seed1));
    float rand2 = rand(vec2(seed0 + 1, seed1 + 1));
    float rand2s = sqrt(rand2);
    
    vec3 w = normal_facing;
    vec3 axis = abs(w.x) > 0.1f ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);
    vec3 u = normalize(cross(axis, w));
    vec3 v = cross(w, u);
    
    vec3 newdir = normalize(u*cos(rand1)*rand2s + v*sin(rand1)*rand2s + w*sqrt(1.0f - rand2));
    //vec3 newdir = normalize(u + v + w);
    //vec3 newdir = cross(dir, normalize(u + v + w));
    //vec3 newdir = normal;
    
    origin = hitpoint + normal_facing * EPSILON;
    dir = newdir;
    
    // accum_color += mask * hitbox.emi;
    // mask *= hitbox.color;
    accum_color += mask * materials[info.i].emission;
    mask *= materials[info.i].color;
    mask *= dot(newdir, normal_facing);
  }
  return accum_color;
}

layout(local_size_x = 8, local_size_y = 8) in;
void main(void) {
  ivec2 px = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebufferImage);
  if (any(greaterThanEqual(px, size)))
    return;
  vec2 p = (vec2(px) + vec2(0.5)) / vec2(size);
  //vec2 p = (vec2(px) / vec2(size));
  vec3 dir = mix(mix(cam[1], cam[2], p.y), mix(cam[3], cam[4], p.y), p.x);
  
  
  vec3 finalcolor = vec3(0.0f, 0.0f, 0.0f);
  int samples = SAMPLES;
  float invsamples = 1.0f / SAMPLES;
  
  for(int i = 0; i < samples; i++){
    finalcolor += trace(camPos, normalize(dir), 
        px.x + rand(vec2(i, i)) + rand(vec2(i+1, i+1)), 
        px.y + rand(vec2(i, i)) + rand(vec2(i+1, i+1))) * invsamples;
    //finalcolor += trace(cam[0], normalize(dir), wang_hash(px.x*samples + i), wang_hash(px.y*samples + i)) * invsamples;
  }
  //finalcolor = trace(cam[0], normalize(dir), rand(vec2(px.x, frameNumber)), rand(vec2(px.y, frameNumber)));
  vec3 tempColor = finalcolor;
  // for(int i=0; i<bufferEnd; i++){
  //   if(texelFetch(bufferTex, i).r != 0){
  //     debugColor = vec3(0, 1, 0);
  //   }
  // }
  Node debugNode = extractNode(16);
  if(debugNode.cp == 72) debugColor = vec3(0, 1, 0);
  if(px.x < 10 && px.y < 10) finalcolor = debugColor;
  /*if(frameNumber > 0){
    tempColor = imageLoad(framebufferImage, px).xyz + finalcolor;
    float temp = frameNumber;
    tempColor = tempColor / temp;  
    tempColor = vec3(
        clamp(tempColor.x, 0.0f, 1.0f),
        clamp(tempColor.y, 0.0f, 1.0f),
        clamp(tempColor.z, 0.0f, 1.0f)
    );
  }*/
  
  imageStore(framebufferImage, px, (vec4(finalcolor, 1.0)));
}